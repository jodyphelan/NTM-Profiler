#! /usr/bin/env python3
import sys
import argparse
import ntm_profiler as ntmp
import os
import pathogenprofiler as pp
from uuid import uuid4
import json
import glob
import atexit

__softwarename__ = "ntm-profiler"

@atexit.register
def cleanup():
    if "last_traceback" in vars(sys):
        if args.files_prefix and not args.no_clean:
            sys.stderr.write("Cleaning up after failed run\n")
            for f in glob.glob(args.files_prefix+"*"):
                os.remove(f)
        import traceback
        
        if "prefix" in vars(args):
            outfile = "%s.errlog" % args.prefix
        elif "vcf" in vars(args):
            outfile = "%s.errlog" % args.vcf.split("/")[-1]
        elif "outfile" in vars(args):
            outfile = "%s.errlog" % args.outfile
        else:
            outfile = "%s.errlog" % uuid4()
        with open(outfile, "w") as O:
            O.write("# ntm-profiler error report\n\n")
            O.write("* OS: %s\n" % sys.platform)
            O.write("* Program version: %s\n" % ntmp.__version__)
            O.write("* Database version: %s\n" % json.load(open(args.conf["version"]))["commit"]) if "conf" in vars(args) else ""
            O.write("* Program call:\n")
            O.write("```\n")
            O.write("%s\n" % vars(args))
            O.write("```\n")

            O.write("## Traceback:\n")
            O.write("```\n")
            traceback.print_tb(sys.last_traceback,file=O)
            O.write("```\n")

            O.write("## Value:\n")
            O.write("```\n")
            O.write("%s" % sys.last_value)
            O.write("```\n")
        pp.errlog("""\n
################################# ERROR #######################################

This run has failed. Please check all arguments and make sure all input files
exist. If no solution is found, please open up an issue at
https://github.com/jodyphelan/NTM-Profiler/issues/new and paste or attach the
contents of the error log (%s)

###############################################################################
""" % (outfile))



def main_profile(args):

    ### Create folders for results if they don't exist ###
    if pp.nofolder(args.dir):
        os.mkdir(args.dir)

    json_output = args.dir+"/"+args.prefix+".results.json"
    text_output = args.dir+"/"+args.prefix+".results.txt"
    csv_output = args.dir+"/"+args.prefix+".results.csv"
    extra_columns = [x.lower() for x in args.add_columns.split(",")] if args.add_columns else []

    if args.external_species_db:
        species_db = pp.get_species_db(args.software_name,args.external_species_db)
    else:
        species_db = pp.get_species_db(args.software_name,args.species_db)

    

    if not args.no_species:
        ### Run profiling module from pathogen-profiler ###
        species_prediction = pp.speciate(args)
    else:
        species_prediction = {}


    results = {"id":args.prefix,"species": species_prediction}
    results['software_version'] = ntmp.__version__
    results['pipeline_software'] = [{"Analysis":"Kmer counting","Program":"kmc"}]
    results['species_db_version'] = json.load(open(species_db["version"]))

    if not args.external_resistance_db and not args.resistance_db:
        if len(species_prediction)==1:
            sys.stderr.write("No resistance database was specified. Attempting to use database based on species prediction...\n")
            db_name = species_prediction[0]["species"].replace(" ","_")
            conf = pp.get_resistance_db(args.software_name,db_name)
        if len(species_prediction)>1 or len(species_prediction)==0 or not os.path.isfile(conf["ref"]):
            if len(species_prediction)>1:
                sys.stderr.write(f"Multiple species found.\n")
            elif len(species_prediction)==0:
                sys.stderr.write(f"Species classification failed.\n")
            elif not os.path.isfile(conf["ref"]):
                sys.stderr.write(f"No resistance db found for {db_name}.\n")
            
            conf = None

            json.dump(results,open(json_output,"w"))
            if args.txt:
                ntmp.write_text(results,conf,text_output,extra_columns,reporting_af=args.reporting_af,sep="\t")
            if args.csv:
                ntmp.write_text(results,conf,text_output,extra_columns,reporting_af=args.reporting_af,sep=",")

            sys.stderr.write("Profiling complete!\n")
            quit(0)
        conf = pp.get_resistance_db(args.software_name,db_name)
    elif args.external_resistance_db:
        conf = pp.get_resistance_db(args.software_name,args.external_resistance_db)
    elif args.resistance_db:
        conf = pp.get_resistance_db(args.software_name,args.resistance_db)
    args.conf = conf


    args = pp.set_platform_params(args)
    bam_file = pp.get_bam_file(args)
    args.missing_cov_threshold = args.min_depth

    results.update(pp.bam_profiler(
        conf=conf, bam_file=bam_file, prefix=args.files_prefix, platform=args.platform,
        caller=args.caller, threads=args.threads, no_flagstat=args.no_flagstat,
        run_delly = args.run_delly, calling_params=args.calling_params,
        coverage_fraction_threshold=args.coverage_fraction_threshold,
        missing_cov_threshold=args.missing_cov_threshold, samclip=args.no_clip,
        min_depth=args.min_depth,delly_vcf_file=args.delly_vcf,call_wg=args.call_whole_genome,
        variant_annotations=args.add_variant_annotations
    ))


    results["resistance_genes"] = ntmp.test_resistance_genes(conf,results)
    

    results["pipeline_software"].extend([
        {"Analysis":"Mapping","Program": args.mapper if not args.bam else "N/A"},
        {"Analysis":"Variant calling","Program":args.caller}
    ])
    results["resistance_db_version"] = json.load(open(conf["version"]))

    results = ntmp.reformat(results,conf)

    
    

    json.dump(results,open(json_output,"w"))
    if args.txt:
        ntmp.write_text(results,conf,text_output,extra_columns,reporting_af=args.reporting_af)
    if args.csv:
        ntmp.write_text(results,conf,csv_output,extra_columns)

    ### Move files to respective directories ###
    result_files = {
        "%s.delly.bcf" % args.files_prefix: "%s/%s.delly.bcf" % (args.dir,args.prefix),
        "%s.targets.csq.vcf.gz" % args.files_prefix: "%s/%s.targets.csq.vcf.gz" % (args.dir,args.prefix),
        "%s.vcf.gz" % args.files_prefix: "%s/%s.vcf.gz" % (args.dir,args.prefix),
        "%s.bam" % args.files_prefix: "%s/%s.bam" % (args.dir,args.prefix),
        "%s.bam.bai" % args.files_prefix: "%s/%s.bam.bai" % (args.dir,args.prefix),
    }

    for file,target in result_files.items():
        if os.path.isfile(file):
            os.rename(file,target)

    pp.run_cmd(f"rm {args.files_prefix}*")

def create_species_db(args):
    pp.create_species_db(args)

def create_resistance_db(args):
    pp.create_db(args,extra_files=[])


def main_speciate(args):
    ### Create folders for results if they don't exist ###
    if pp.nofolder(args.dir):
        os.mkdir(args.dir)

    ### Setup prefix for files ###

    json_output = args.dir+"/"+args.prefix+".results.json"
    text_output = args.dir+"/"+args.prefix+".results.txt"
    csv_output = args.dir+"/"+args.prefix+".results.csv"
    extra_columns = [x.lower() for x in args.add_columns.split(",")] if args.add_columns else []

    if args.external_species_db:
        species_db = ntmp.get_species_db(args.external_species_db)
    else:
        species_db = ntmp.get_species_db(args.species_db)

    if args.bam==None:
        species_prediction = ntmp.check_for_kmers(species_db["kmers"],args.read1,args.read2,threads=args.threads)
    else:
        pp.run_cmd(f"samtools fastq {args.bam} > {args.files_prefix}.fq")
        species_prediction = ntmp.check_for_kmers(species_db["kmers"],args.files_prefix+".fq",threads=args.threads)

    results = {"id":args.prefix,"species": species_prediction}
    results['software_version'] = ntmp.__version__
    results['pipeline_software'] = [{"Analysis":"Kmer counting","Program":"dsk"}]
    results['species_db_version'] = json.load(open(species_db["version"]))

    json.dump(results,open(json_output,"w"))
    if args.txt:
        ntmp.write_text(results,species_db,text_output,extra_columns,sep="\t")
    if args.csv:
        ntmp.write_text(results,species_db,csv_output,extra_columns,sep=",")

    pp.successlog("Profiling complete!")


def main_fasta_profile(args):
    if not args.no_species:
        ### Run profiling module from pathogen-profiler ###
        species_prediction = pp.speciate(args)
    else:
        species_prediction = {}

    results = {"id":args.prefix,"species":species_prediction}
    results['software_version'] = ntmp.__version__
    results['pipeline_software'] = []
    conf = pp.get_resistance_db(args.software_name,args.resistance_db)
    results.update(pp.fasta_profiler(conf=conf,prefix=args.prefix,filename=args.fasta))
    results["resistance_genes"] = ntmp.test_resistance_genes(conf,results)

    results["pipeline_software"].extend([
        {"Analysis":"Variant calling","Program":args.caller}
    ])
    results["resistance_db_version"] = json.load(open(conf["version"]))

    results = ntmp.reformat(results,conf)


    json_output = args.dir+"/"+args.prefix+".results.json"
    text_output = args.dir+"/"+args.prefix+".results.txt"
    csv_output = args.dir+"/"+args.prefix+".results.csv"

    extra_columns = []
    json.dump(results,open(json_output,"w"))
    if args.txt:
        ntmp.write_text(results,conf,text_output,extra_columns)
    if args.csv:
        ntmp.write_text(results,conf,csv_output,extra_columns)

    pp.run_cmd(f"rm {args.files_prefix}*")


def main_collate(args):
    ntmp.collate(args)


def main_update_db(args):
    if os.path.isdir('ntmdb'):
        os.chdir('ntmdb')
        pp.run_cmd('git pull')
        os.chdir('db/')
    else:
        pp.run_cmd('git clone https://github.com/jodyphelan/ntmdb.git')
        os.chdir('ntmdb/db/')
    dirs = [d for d in os.listdir() if os.path.isdir(d)]
    pp.infolog('\nCreating species DB')
    pp.run_cmd('ntm-profiler create_species_db -p ntmdb --kmers ntm_db.kmers.txt --load')
    for d in dirs:
        os.chdir(d)
        for species in json.load(open('variables.json'))['species']:
            pp.infolog(f'\nCreating DB for {species}')
            pp.run_cmd(f'ntm-profiler create_resistance_db --prefix {species.replace(" ","_")} --csv resistance_variants.csv --load')
        os.chdir('../')



#### Argument Parsing ####

parser = argparse.ArgumentParser(description='NTM-Profiler pipeline',formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('--version', action='version', version="NTM-Profiler version %s" % ntmp.__version__)
parser.add_argument('--no_clean', action='store_true', help=argparse.SUPPRESS)
subparsers = parser.add_subparsers(help="Task to perform")


###### Profile #######
parser_sub = subparsers.add_parser('profile', help='Run whole profiling pipeline', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
input=parser_sub.add_argument_group("Input options")
group = input.add_mutually_exclusive_group(required=True)
group.add_argument('--read1','-1',help='First read file')
input.add_argument('--read2','-2',help='Second read file')
group.add_argument('--bam','-a',help='BAM file. Make sure it has been generated using the H37Rv genome (GCA_000195955.2)')
input.add_argument('--platform','-m',choices=["illumina","nanopore"],default="illumina",help='NGS Platform used to generate data')
input.add_argument('--resistance_db',help='Mutation panel name')
input.add_argument('--external_resistance_db',type=str,help='Path to db files prefix (overrides "--db" parameter)')
input.add_argument('--species_db',default='ntmdb',help='Mutation panel name')
input.add_argument('--external_species_db',type=str,help='Path to db files prefix (overrides "--db" parameter)')

output=parser_sub.add_argument_group("Output options")
output.add_argument('--prefix','-p',default="ntmprofiler",help='Sample prefix for all results generated')
output.add_argument('--dir','-d',default=".",help='Storage directory')
output.add_argument('--csv',action="store_true",help="Add CSV output")
output.add_argument('--txt',action="store_true",help="Add text output")
# output.add_argument('--pdf',action="store_true",help="Add PDF output. This requires pdflatex to be installed")
output.add_argument('--add_columns',default=None,type=str,help="Add additional columns found in the mutation database to the text and csv results")
output.add_argument('--add_mutation_metadata',action="store_true",help=argparse.SUPPRESS)
output.add_argument('--call_whole_genome',action="store_true",help="Call whole genome")

algorithm=parser_sub.add_argument_group("Algorithm options")
algorithm.add_argument('--mapper',default="bwa", choices=["bwa","minimap2","bowtie2","bwa-mem2"],help="Mapping tool to use. If you are using nanopore data it will default to minimap2",type=str)
algorithm.add_argument('--caller',default="freebayes", choices=["bcftools","gatk","freebayes"],help="Variant calling tool to use.",type=str)
algorithm.add_argument('--calling_params',type=str,help='Override default parameters for variant calling')
algorithm.add_argument('--min_depth',default=10,type=int,help='Minimum depth required to call variant. Bases with depth below this cutoff will be marked as missing')
algorithm.add_argument('--af',default=0.1,type=float,help='Minimum allele frequency to call variants')
algorithm.add_argument('--reporting_af',default=0.1,type=float,help='Minimum allele frequency to use variants for prediction')
algorithm.add_argument('--coverage_fraction_threshold',default=0,type=int,help='Cutoff used to calculate fraction of region covered by <= this value')
algorithm.add_argument('--missing_cov_threshold',type=int,help='Cutoff used to positions/codons in genes which are missing (this argument has now been merged with --min_depth argument and will be deprecated in future releases)')
algorithm.add_argument('--no_trim',action="store_true",help="Don't trim files using trimmomatic")
algorithm.add_argument('--no_flagstat',action="store_true",help="Don't collect flagstats")
algorithm.add_argument('--no_clip',action="store_false",help="Don't clip reads")
algorithm.add_argument('--no_delly',action="store_true",help="Don't run delly")
algorithm.add_argument('--no_species',action="store_true",help=argparse.SUPPRESS)
algorithm.add_argument('--add_variant_annotations',action="store_true",help=argparse.SUPPRESS)
algorithm.add_argument('--threads','-t',default=1,help='Threads to use',type=int)

other=parser_sub.add_argument_group("Other options")
other.add_argument('--verbose','-v',default=0, choices=[0,1,2],help="Verbosity increases from 0 to 2",type=int)
other.add_argument('--version', action='version', version="NTM-Profiler version %s" % ntmp.__version__)
other.add_argument('--no_cleanup',action="store_true",help="Don't remove temporary files on error")
other.add_argument('--delly_vcf',help=argparse.SUPPRESS)
parser_sub.set_defaults(func=main_profile)


parser_sub = subparsers.add_parser('collate', help='Collate results form multiple samples together', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser_sub.add_argument('--outfile','-o',default="ntmprofiler.collate.txt",help='Sample prefix')
parser_sub.add_argument('--samples',help='File with samples (one per line)')
parser_sub.add_argument('--dir','-d',default=".",help='Storage directory')
parser_sub.add_argument('--suffix',default=".results.json",type=str,help='Input results files suffix')
parser_sub.add_argument('--format',default="txt",choices=["txt","csv"],type=str,help='Output file type')
parser_sub.add_argument('--version', action='version', version="NTM-Profiler version %s" % ntmp.__version__)
parser_sub.set_defaults(func=main_collate)

parser_sub = subparsers.add_parser('speciate', help='Run speciation pipeline', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
input=parser_sub.add_argument_group("Input options")
group = input.add_mutually_exclusive_group(required=True)
group.add_argument('--read1','-1',help='First read file')
input.add_argument('--read2','-2',help='Second read file')
group.add_argument('--bam','-a',help='BAM file. Make sure it has been generated using the H37Rv genome (GCA_000195955.2)')
# input.add_argument('--platform','-m',choices=["illumina","nanopore"],default="illumina",help='NGS Platform used to generate data')
input.add_argument('--species_db',default='ntmdb',help='Speciation database name')
input.add_argument('--external_species_db',type=str,help='Path to db files prefix (overrides "--db" parameter)')

output=parser_sub.add_argument_group("Output options")
output.add_argument('--prefix','-p',default="ntmprofiler",help='File prefix for all results generated')
output.add_argument('--dir','-d',default=".",help='Storage directory')
output.add_argument('--csv',action="store_true",help="Add CSV output")
output.add_argument('--txt',action="store_true",help="Add text output")
output.add_argument('--add_columns',default=None,type=str,help=argparse.SUPPRESS)

algorithm=parser_sub.add_argument_group("Algorithm options")
algorithm.add_argument('--threads','-t',default=1,help='Threads to use',type=int)

other=parser_sub.add_argument_group("Other options")
other.add_argument('--verbose','-v',default=0, choices=[0,1,2],help="Verbosity increases from 0 to 2",type=int)
other.add_argument('--version', action='version', version="NTM-Profiler version %s" % ntmp.__version__)
other.add_argument('--no_cleanup',action="store_true",help="Don't remove temporary files on error")
parser_sub.set_defaults(func=main_speciate)



# Update database #
parser_sub = subparsers.add_parser('update_db', help='Update all databases', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser_sub.add_argument('--version', action='version', version="NTM-Profiler version %s" % ntmp.__version__)
parser_sub.add_argument('--dir','-d',default=".",help='Storage directory')
parser_sub.set_defaults(func=main_update_db)




# Create resistance DB #
parser_sub = subparsers.add_parser('create_resistance_db', help='Generate the files required to run resistance profiling with NTM-Profiler', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser_sub.add_argument('--prefix','-p',type=str,help='The name of the database (match species name for automated speciation+resistance detection)',required = True)
parser_sub.add_argument('--csv','-c',type=str,help='The CSV file containing mutations')
parser_sub.add_argument('--load',action="store_true",help='Load the library after creating it')
parser_sub.add_argument('--watchlist','-w',type=str,help='A csv file containing genes to profile but without any specific associated mutations')
parser_sub.add_argument('--match_ref',type=str,help='The prefix for all output files')
parser_sub.add_argument('--other_annotations',type=str,help='The prefix for all output files')
parser_sub.add_argument('--custom',action="store_true",help='Tells the script this is a custom database, this is used to alter the generation of the version file')
parser_sub.add_argument('--db-name',help='Overrides the name of the database in the version file')
parser_sub.add_argument('--db-commit',help='Overrides the commit string of the database in the version file')
parser_sub.add_argument('--db-author',help='Overrides the author of the database in the version file')
parser_sub.add_argument('--db-date',help='Overrides the date of the database in the version file')
parser_sub.add_argument('--include_original_mutation',action="store_true", help='Include the original mutation (before reformatting) as part of the variant annotaion')
parser_sub.add_argument('--version', action='version', version="NTM-Profiler version %s" % ntmp.__version__)
parser_sub.add_argument('--dir','-d',default=".",help='Storage directory')
parser_sub.set_defaults(func=create_resistance_db)

# parser_sub = subparsers.add_parser('load_resistance_db', help='Load the resistance database files', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
# parser_sub.add_argument('--prefix','-p',type=str,help='The input CSV file containing the mutations',required = True)
# parser_sub.add_argument('--version', action='version', version="NTM-Profiler version %s" % ntmp.__version__)
# parser_sub.set_defaults(func=load_resistance_db)

parser_sub = subparsers.add_parser('create_species_db', help='Generate the files required to run speciation with NTM-Profiler', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser_sub.add_argument('--prefix','-p',type=str,help='The name of the database',required = True)
parser_sub.add_argument('--kmers',type=str,help='The file containing species specific kmers',required = True)
parser_sub.add_argument('--load',action="store_true",help='Load the library after creating it',required = True)
parser_sub.add_argument('--db-name',help='Overrides the name of the database in the version file')
parser_sub.add_argument('--db-commit',help='Overrides the commit string of the database in the version file')
parser_sub.add_argument('--db-author',help='Overrides the author of the database in the version file')
parser_sub.add_argument('--db-date',help='Overrides the date of the database in the version file')
parser_sub.add_argument('--version', action='version', version="NTM-Profiler version %s" % ntmp.__version__)
parser_sub.add_argument('--dir','-d',default=".",help='Storage directory')
parser_sub.set_defaults(func=create_species_db)

# parser_sub = subparsers.add_parser('load_species_db', help='Load the species database files', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
# parser_sub.add_argument('--prefix','-p',type=str,help='The name of the database',required = True)
# parser_sub.add_argument('--version', action='version', version="NTM-Profiler version %s" % ntmp.__version__)
# parser_sub.set_defaults(func=load_species_db)


parser_sub = subparsers.add_parser('fasta_profile', help='Run whole profiling pipeline', formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser_sub.add_argument('--fasta','-f',help='First read file')
parser_sub.add_argument('--prefix','-p',default="ntmprofiler",help='Sample prefix for all results generated')
parser_sub.add_argument('--resistance_db',help='Mutation panel name')
parser_sub.add_argument('--external_resistance_db',type=str,help='Path to db files prefix (overrides "--db" parameter)')
parser_sub.add_argument('--species_db',default='ntmdb',help='Mutation panel name')
parser_sub.add_argument('--external_species_db',type=str,help='Path to db files prefix (overrides "--db" parameter)')
parser_sub.add_argument('--dir','-d',default=".",help='Storage directory')
parser_sub.add_argument('--caller',default="paftools.js", choices=["paftools.js"],help="Variant calling tool to use.",type=str)
parser_sub.add_argument('--csv',action="store_true",help="Add CSV output")
parser_sub.add_argument('--txt',action="store_true",help="Add text output")
parser_sub.add_argument('--no_species',action="store_true",help=argparse.SUPPRESS)

parser_sub.add_argument('--threads','-t',default=1,help='Threads to use',type=int)
parser_sub.set_defaults(func=main_fasta_profile)




args = parser.parse_args()
if hasattr(args, 'func'):
    args.software_name = __softwarename__
    args.tmp_prefix = str(uuid4())
    args.files_prefix = args.dir+"/"+args.tmp_prefix

    args.func(args)
else:
    parser.print_help(sys.stderr)